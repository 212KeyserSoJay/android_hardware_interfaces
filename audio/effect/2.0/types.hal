/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.audio.effect@2.0;

import android.hardware.audio.common@2.0;

enum Result {
    OK,
    NOT_INITIALIZED,
    INVALID_ARGUMENTS,
    INVALID_STATE,
    NOT_SUPPORTED
};

/*
 * Effect engine capabilities/requirements flags.
 *
 * Definitions for flags field of effect descriptor.
 *
 * +----------------+--------+--------------------------------------------------
 * | description    | bits   | values
 * +----------------+--------+--------------------------------------------------
 * | connection     | 0..2   | 0 insert: after track process
 * | mode           |        | 1 auxiliary: connect to track auxiliary
 * |                |        |  output and use send level
 * |                |        | 2 replace: replaces track process function;
 * |                |        |   must implement SRC, volume and mono to stereo.
 * |                |        | 3 pre processing: applied below audio HAL on in
 * |                |        | 4 post processing: applied below audio HAL on out
 * |                |        | 5 - 7 reserved
 * +----------------+--------+--------------------------------------------------
 * | insertion      | 3..5   | 0 none
 * | preference     |        | 1 first of the chain
 * |                |        | 2 last of the chain
 * |                |        | 3 exclusive (only effect in the insert chain)
 * |                |        | 4..7 reserved
 * +----------------+--------+--------------------------------------------------
 * | Volume         | 6..8   | 0 none
 * | management     |        | 1 implements volume control
 * |                |        | 2 requires volume indication
 * |                |        | 4 reserved
 * +----------------+--------+--------------------------------------------------
 * | Device         | 9..11  | 0 none
 * | indication     |        | 1 requires device updates
 * |                |        | 2, 4 reserved
 * +----------------+--------+--------------------------------------------------
 * | Sample input   | 12..13 | 1 direct: process() function or
 * | mode           |        |   EFFECT_CMD_SET_CONFIG command must specify
 * |                |        |   a buffer descriptor
 * |                |        | 2 provider: process() function uses the
 * |                |        |   bufferProvider indicated by the
 * |                |        |   EFFECT_CMD_SET_CONFIG command to request input.
 * |                |        |   buffers.
 * |                |        | 3 both: both input modes are supported
 * +----------------+--------+--------------------------------------------------
 * | Sample output  | 14..15 | 1 direct: process() function or
 * | mode           |        |   EFFECT_CMD_SET_CONFIG command must specify
 * |                |        |   a buffer descriptor
 * |                |        | 2 provider: process() function uses the
 * |                |        |   bufferProvider indicated by the
 * |                |        |   EFFECT_CMD_SET_CONFIG command to request output
 * |                |        |   buffers.
 * |                |        | 3 both: both output modes are supported
 * +----------------+--------+--------------------------------------------------
 * | Hardware       | 16..17 | 0 No hardware acceleration
 * | acceleration   |        | 1 non tunneled hw acceleration: the process()
 * |                |        |   function reads the samples, send them to HW
 * |                |        |   accelerated effect processor, reads back
 * |                |        |   the processed samples and returns them
 * |                |        |   to the output buffer.
 * |                |        | 2 tunneled hw acceleration: the process()
 * |                |        |   function is transparent. The effect interface
 * |                |        |   is only used to control the effect engine.
 * |                |        |   This mode is relevant for global effects
 * |                |        |   actually applied by the audio hardware on
 * |                |        |   the output stream.
 * +----------------+--------+--------------------------------------------------
 * | Audio Mode     | 18..19 | 0 none
 * | indication     |        | 1 requires audio mode updates
 * |                |        | 2..3 reserved
 * +----------------+--------+--------------------------------------------------
 * | Audio source   | 20..21 | 0 none
 * | indication     |        | 1 requires audio source updates
 * |                |        | 2..3 reserved
 * +----------------+--------+--------------------------------------------------
 * | Effect offload | 22     | 0 The effect cannot be offloaded to an audio DSP
 * | supported      |        | 1 The effect can be offloaded to an audio DSP
 * +----------------+--------+--------------------------------------------------
 * | Process        | 23     | 0 The effect implements a process function.
 * | function       |        | 1 The effect does not implement a process
 * | not            |        |   function: enabling the effect has no impact
 * | implemented    |        |   on latency or CPU load.
 * |                |        |   Effect implementations setting this flag do not
 * |                |        |   have to implement a process function.
 * +----------------+--------+--------------------------------------------------
 */
// TODO(mnaganov): Consider if "EFFECT_FLAG_" prefix can be dropped.
enum EffectFlags {
    // Insert mode
    EFFECT_FLAG_TYPE_SHIFT = 0,
    EFFECT_FLAG_TYPE_SIZE = 3,
    EFFECT_FLAG_TYPE_MASK =
        ((1 << EFFECT_FLAG_TYPE_SIZE) -1) << EFFECT_FLAG_TYPE_SHIFT,
    EFFECT_FLAG_TYPE_INSERT = 0 << EFFECT_FLAG_TYPE_SHIFT,
    EFFECT_FLAG_TYPE_AUXILIARY = 1 << EFFECT_FLAG_TYPE_SHIFT,
    EFFECT_FLAG_TYPE_REPLACE = 2 << EFFECT_FLAG_TYPE_SHIFT,
    EFFECT_FLAG_TYPE_PRE_PROC = 3 << EFFECT_FLAG_TYPE_SHIFT,
    EFFECT_FLAG_TYPE_POST_PROC = 4 << EFFECT_FLAG_TYPE_SHIFT,

    // Insert preference
    EFFECT_FLAG_INSERT_SHIFT = EFFECT_FLAG_TYPE_SHIFT + EFFECT_FLAG_TYPE_SIZE,
    EFFECT_FLAG_INSERT_SIZE = 3,
    EFFECT_FLAG_INSERT_MASK =
        ((1 << EFFECT_FLAG_INSERT_SIZE) -1) << EFFECT_FLAG_INSERT_SHIFT,
    EFFECT_FLAG_INSERT_ANY = 0 << EFFECT_FLAG_INSERT_SHIFT,
    EFFECT_FLAG_INSERT_FIRST = 1 << EFFECT_FLAG_INSERT_SHIFT,
    EFFECT_FLAG_INSERT_LAST = 2 << EFFECT_FLAG_INSERT_SHIFT,
    EFFECT_FLAG_INSERT_EXCLUSIVE = 3 << EFFECT_FLAG_INSERT_SHIFT,

    // Volume control
    EFFECT_FLAG_VOLUME_SHIFT =
        EFFECT_FLAG_INSERT_SHIFT + EFFECT_FLAG_INSERT_SIZE,
    EFFECT_FLAG_VOLUME_SIZE = 3,
    EFFECT_FLAG_VOLUME_MASK =
        ((1 << EFFECT_FLAG_VOLUME_SIZE) -1) << EFFECT_FLAG_VOLUME_SHIFT,
    EFFECT_FLAG_VOLUME_CTRL = 1 << EFFECT_FLAG_VOLUME_SHIFT,
    EFFECT_FLAG_VOLUME_IND = 2 << EFFECT_FLAG_VOLUME_SHIFT,
    EFFECT_FLAG_VOLUME_NONE = 0 << EFFECT_FLAG_VOLUME_SHIFT,

    // Device indication
    EFFECT_FLAG_DEVICE_SHIFT =
        EFFECT_FLAG_VOLUME_SHIFT + EFFECT_FLAG_VOLUME_SIZE,
    EFFECT_FLAG_DEVICE_SIZE = 3,
    EFFECT_FLAG_DEVICE_MASK =
        ((1 << EFFECT_FLAG_DEVICE_SIZE) -1) << EFFECT_FLAG_DEVICE_SHIFT,
    EFFECT_FLAG_DEVICE_IND = 1 << EFFECT_FLAG_DEVICE_SHIFT,
    EFFECT_FLAG_DEVICE_NONE = 0 << EFFECT_FLAG_DEVICE_SHIFT,

    // Sample input modes
    EFFECT_FLAG_INPUT_SHIFT =
        EFFECT_FLAG_DEVICE_SHIFT + EFFECT_FLAG_DEVICE_SIZE,
    EFFECT_FLAG_INPUT_SIZE = 2,
    EFFECT_FLAG_INPUT_MASK =
        ((1 << EFFECT_FLAG_INPUT_SIZE) -1) << EFFECT_FLAG_INPUT_SHIFT,
    EFFECT_FLAG_INPUT_DIRECT = 1 << EFFECT_FLAG_INPUT_SHIFT,
    EFFECT_FLAG_INPUT_PROVIDER = 2 << EFFECT_FLAG_INPUT_SHIFT,
    EFFECT_FLAG_INPUT_BOTH = 3 << EFFECT_FLAG_INPUT_SHIFT,

    // Sample output modes
    EFFECT_FLAG_OUTPUT_SHIFT = EFFECT_FLAG_INPUT_SHIFT + EFFECT_FLAG_INPUT_SIZE,
    EFFECT_FLAG_OUTPUT_SIZE = 2,
    EFFECT_FLAG_OUTPUT_MASK =
        ((1 << EFFECT_FLAG_OUTPUT_SIZE) -1) << EFFECT_FLAG_OUTPUT_SHIFT,
    EFFECT_FLAG_OUTPUT_DIRECT = 1 << EFFECT_FLAG_OUTPUT_SHIFT,
    EFFECT_FLAG_OUTPUT_PROVIDER = 2 << EFFECT_FLAG_OUTPUT_SHIFT,
    EFFECT_FLAG_OUTPUT_BOTH = 3 << EFFECT_FLAG_OUTPUT_SHIFT,

    // Hardware acceleration mode
    EFFECT_FLAG_HW_ACC_SHIFT =
        EFFECT_FLAG_OUTPUT_SHIFT + EFFECT_FLAG_OUTPUT_SIZE,
    EFFECT_FLAG_HW_ACC_SIZE = 2,
    EFFECT_FLAG_HW_ACC_MASK =
        ((1 << EFFECT_FLAG_HW_ACC_SIZE) -1) << EFFECT_FLAG_HW_ACC_SHIFT,
    EFFECT_FLAG_HW_ACC_SIMPLE = 1 << EFFECT_FLAG_HW_ACC_SHIFT,
    EFFECT_FLAG_HW_ACC_TUNNEL = 2 << EFFECT_FLAG_HW_ACC_SHIFT,

    // Audio mode indication
    EFFECT_FLAG_AUDIO_MODE_SHIFT =
        EFFECT_FLAG_HW_ACC_SHIFT + EFFECT_FLAG_HW_ACC_SIZE,
    EFFECT_FLAG_AUDIO_MODE_SIZE = 2,
    EFFECT_FLAG_AUDIO_MODE_MASK =
        ((1 << EFFECT_FLAG_AUDIO_MODE_SIZE) -1) << EFFECT_FLAG_AUDIO_MODE_SHIFT,
    EFFECT_FLAG_AUDIO_MODE_IND = 1 << EFFECT_FLAG_AUDIO_MODE_SHIFT,
    EFFECT_FLAG_AUDIO_MODE_NONE = 0 << EFFECT_FLAG_AUDIO_MODE_SHIFT,

    // Audio source indication
    EFFECT_FLAG_AUDIO_SOURCE_SHIFT =
        EFFECT_FLAG_AUDIO_MODE_SHIFT + EFFECT_FLAG_AUDIO_MODE_SIZE,
    EFFECT_FLAG_AUDIO_SOURCE_SIZE = 2,
    EFFECT_FLAG_AUDIO_SOURCE_MASK = ((1 << EFFECT_FLAG_AUDIO_SOURCE_SIZE) -1)
        << EFFECT_FLAG_AUDIO_SOURCE_SHIFT,
    EFFECT_FLAG_AUDIO_SOURCE_IND = 1 << EFFECT_FLAG_AUDIO_SOURCE_SHIFT,
    EFFECT_FLAG_AUDIO_SOURCE_NONE = 0 << EFFECT_FLAG_AUDIO_SOURCE_SHIFT,

    // Effect offload indication
    EFFECT_FLAG_OFFLOAD_SHIFT =
        EFFECT_FLAG_AUDIO_SOURCE_SHIFT + EFFECT_FLAG_AUDIO_SOURCE_SIZE,
    EFFECT_FLAG_OFFLOAD_SIZE = 1,
    EFFECT_FLAG_OFFLOAD_MASK =
        ((1 << EFFECT_FLAG_OFFLOAD_SIZE) -1) << EFFECT_FLAG_OFFLOAD_SHIFT,
    EFFECT_FLAG_OFFLOAD_SUPPORTED = 1 << EFFECT_FLAG_OFFLOAD_SHIFT,

    // Effect has no process indication
    EFFECT_FLAG_NO_PROCESS_SHIFT =
        EFFECT_FLAG_OFFLOAD_SHIFT + EFFECT_FLAG_OFFLOAD_SIZE,
    EFFECT_FLAG_NO_PROCESS_SIZE = 1,
    EFFECT_FLAG_NO_PROCESS_MASK =
        ((1 << EFFECT_FLAG_NO_PROCESS_SIZE) -1) << EFFECT_FLAG_NO_PROCESS_SHIFT,
    EFFECT_FLAG_NO_PROCESS = 1 << EFFECT_FLAG_NO_PROCESS_SHIFT
};

/*
 * The effect descriptor contains necessary information to facilitate the
 * enumeration of the effect engines present in a library.
 */
struct EffectDescriptor {
    Uuid type;             // UUID of to the OpenSL ES interface implemented
                           // by this effect
    Uuid uuid;             // UUID for this particular implementation
    EffectFlags flags;     // effect engine capabilities/requirements flags
    uint16_t cpuLoad;      // CPU load indication expressed in 0.1 MIPS units
                           // as estimated on an ARM9E core (ARMv5TE) with 0 WS
    uint16_t memoryUsage;  // data memory usage expressed in KB and includes
                           // only dynamically allocated memory
    string name;           // human readable effect name
    string implementor;    // human readable effect implementor name
};

/*
 * A buffer is a chunk of audio data for processing.  Multi-channel audio is
 * always interleaved. The channel order is from LSB to MSB with regard to the
 * channel mask definition in audio.h, audio_channel_mask_t, e.g.:
 * Stereo: L, R; 5.1: FL, FR, FC, LFE, BL, BR.
 *
 * The buffer size is expressed in frame count, a frame being composed of
 * samples for all channels at a given time. Frame size for unspecified format
 * (AUDIO_FORMAT_OTHER) is 8 bit by definition.
 */
// TODO(mnaganov): replace with FMQ version.
struct AudioBuffer {
    uint32_t frameCount;
    vec<uint8_t> data;
};

enum EffectBufferAccess {
    EFFECT_BUFFER_ACCESS_WRITE,
    EFFECT_BUFFER_ACCESS_READ,
    EFFECT_BUFFER_ACCESS_ACCUMULATE
};

/*
 * Determines what fields of EffectBufferConfig need to be considered.
 */
enum EffectConfigParameters {
    EFFECT_CONFIG_BUFFER = 0x0001,    // buffer field
    EFFECT_CONFIG_SMP_RATE = 0x0002,  // samplingRate
    EFFECT_CONFIG_CHANNELS = 0x0004,  // channels
    EFFECT_CONFIG_FORMAT = 0x0008,    // format
    EFFECT_CONFIG_ACC_MODE = 0x0010,  // accessMode
    EFFECT_CONFIG_ALL = EFFECT_CONFIG_BUFFER | EFFECT_CONFIG_SMP_RATE |
                        EFFECT_CONFIG_CHANNELS | EFFECT_CONFIG_FORMAT |
                        EFFECT_CONFIG_ACC_MODE
};

/*
 * The buffer config structure specifies the input or output audio format
 * to be used by the effect engine.
 */
struct EffectBufferConfig {
    AudioBuffer buffer;
    uint32_t samplingRateHz;
    AudioChannelMask channels;
    AudioFormat format;
    EffectBufferAccess accessMode;
    EffectConfigParameters mask;
};

struct EffectConfig {
    EffectBufferConfig inputCfg;
    EffectBufferConfig outputCfg;
};

enum EffectFeature {
    EFFECT_FEATURE_AUX_CHANNELS, // supports auxiliary channels
                                 // (e.g. dual mic noise suppressor)
    EFFECT_FEATURE_CNT
};

struct EffectFeatureConfig {
    EffectFeature feature;
    EffectConfig config;
};

struct EffectOffloadParameter {
    bool isOffload;          // true if the playback thread the effect
                             // is attached to is offloaded
    AudioIoHandle ioHandle;  // io handle of the playback thread
                             // the effect is attached to
};
