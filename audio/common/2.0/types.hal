/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.audio.common@2.0;

/*
 *
 *  IDs and Handles
 *
 */

/*
 * Handle type for identifying audio sources and sinks.
 */
typedef int32_t AudioIoHandle;

/*
 * Audio hw module handle functions or structures referencing a module.
 */
typedef int32_t AudioModuleHandle;

/*
 * Each port has a unique ID or handle allocated by policy manager.
 */
typedef int32_t AudioPortHandle;

/*
 * Each patch is identified by a handle at the interface used to create that
 * patch. For instance, when a patch is created by the audio HAL, the HAL
 * allocates and returns a handle.  This handle is unique to a given audio HAL
 * hardware module.  But the same patch receives another system wide unique
 * handle allocated by the framework.  This unique handle is used for all
 * transactions inside the framework.
 */
typedef int32_t AudioPatchHandle;

/*
 * A HW synchronization source returned by the audio HAL.
 */
typedef uint32_t AudioHwSync;

/*
 * Each port has a unique ID or handle allocated by policy manager.
 */
@export(name="")
enum AudioHandleConsts {
    AUDIO_IO_HANDLE_NONE = 0,
    AUDIO_MODULE_HANDLE_NONE = 0,
    AUDIO_PORT_HANDLE_NONE = 0,
    AUDIO_PATCH_HANDLE_NONE = 0,
};

/*
 * Commonly used structure for passing unique identifieds (UUID).
 * For the definition of UUID, refer to ITU-T X.667 spec.
 */
struct Uuid {
    uint32_t timeLow;
    uint16_t timeMid;
    uint16_t versionAndTimeHigh;
    uint16_t variantAndClockSeqHigh;
    uint8_t[6] node;
};


/*
 *
 *  Audio streams
 *
 */

/*
 * Audio stream type describing the intented use case of a stream.
 */
@export(name="audio_stream_type_t")
enum AudioStreamType : int32_t {
    // These values must kept in sync with
    //  frameworks/base/media/java/android/media/AudioSystem.java
    // TODO: Synchronization should be done automatically by tools
    AUDIO_STREAM_DEFAULT          = -1,
    AUDIO_STREAM_MIN              = 0,
    AUDIO_STREAM_VOICE_CALL       = 0,
    AUDIO_STREAM_SYSTEM           = 1,
    AUDIO_STREAM_RING             = 2,
    AUDIO_STREAM_MUSIC            = 3,
    AUDIO_STREAM_ALARM            = 4,
    AUDIO_STREAM_NOTIFICATION     = 5,
    AUDIO_STREAM_BLUETOOTH_SCO    = 6,
    AUDIO_STREAM_ENFORCED_AUDIBLE = 7,  // Sounds that cannot be muted by user
                                        // and must be routed to speaker
    AUDIO_STREAM_DTMF             = 8,
    AUDIO_STREAM_TTS              = 9,  // Transmitted Through Speaker
                                        // Plays over speaker only, silent
                                        // on other devices
    AUDIO_STREAM_ACCESSIBILITY    = 10, // For accessibility talk back prompts
    AUDIO_STREAM_REROUTING        = 11, // For dynamic policy output mixes
    AUDIO_STREAM_PATCH            = 12, // For internal audio flinger tracks.
                                        // Fixed volume
    AUDIO_STREAM_PUBLIC_CNT       = AUDIO_STREAM_TTS + 1,
    // Number of streams considered by audio policy for volume and routing
    AUDIO_STREAM_FOR_POLICY_CNT   = AUDIO_STREAM_PATCH,
    AUDIO_STREAM_CNT              = AUDIO_STREAM_PATCH + 1
};

@export(name="audio_source_t")
enum AudioSource {
    // These values must kept in sync with
    //  frameworks/base/media/java/android/media/MediaRecorder.java,
    //  frameworks/av/services/audiopolicy/AudioPolicyService.cpp,
    //  system/media/audio_effects/include/audio_effects/audio_effects_conf.h
    AUDIO_SOURCE_DEFAULT             = 0,
    AUDIO_SOURCE_MIC                 = 1,
    AUDIO_SOURCE_VOICE_UPLINK        = 2,
    AUDIO_SOURCE_VOICE_DOWNLINK      = 3,
    AUDIO_SOURCE_VOICE_CALL          = 4,
    AUDIO_SOURCE_CAMCORDER           = 5,
    AUDIO_SOURCE_VOICE_RECOGNITION   = 6,
    AUDIO_SOURCE_VOICE_COMMUNICATION = 7,
    /*
     * Source for the mix to be presented remotely. An example of remote
     * presentation is Wifi Display where a dongle attached to a TV can be used
     * to play the mix captured by this audio source.
     */
    AUDIO_SOURCE_REMOTE_SUBMIX       = 8,
    /*
     * Source for unprocessed sound. Usage examples include level measurement
     * and raw signal analysis.
     */
    AUDIO_SOURCE_UNPROCESSED         = 9,

    AUDIO_SOURCE_CNT,
    AUDIO_SOURCE_MAX                 = AUDIO_SOURCE_CNT - 1,
    AUDIO_SOURCE_FM_TUNER            = 1998,
    /*
     * A low-priority, preemptible audio source for for background software
     * hotword detection. Same tuning as AUDIO_SOURCE_VOICE_RECOGNITION.
     * Used only internally to the framework.
     */
    AUDIO_SOURCE_HOTWORD             = 1999
};

typedef int32_t AudioSession;
/*
 * Special audio session values.
 */
@export(name="audio_session_t")
enum AudioSessionConsts : int32_t {
    /*
     * Session for effects attached to a particular output stream
     * (value must be less than 0)
     */
    AUDIO_SESSION_OUTPUT_STAGE = -1,
    /*
     * Session for effects applied to output mix. These effects can
     * be moved by audio policy manager to another output stream
     * (value must be 0)
     */
    AUDIO_SESSION_OUTPUT_MIX = 0,
    /*
     * Application does not specify an explicit session ID to be used, and
     * requests a new session ID to be allocated TODO use unique values for
     * AUDIO_SESSION_OUTPUT_MIX and AUDIO_SESSION_ALLOCATE, after all uses have
     * been updated from 0 to the appropriate symbol, and have been tested.
     * Corresponds to AudioManager.AUDIO_SESSION_ID_GENERATE and
     * AudioSystem.AUDIO_SESSION_ALLOCATE.
     */
    AUDIO_SESSION_ALLOCATE = 0,
    /*
     * For use with AudioRecord::start(), this indicates no trigger session.
     * It is also used with output tracks and patch tracks, which never have a
     * session.
     */
    AUDIO_SESSION_NONE = 0
};

/*
 * Audio format  is a 32-bit word that consists of:
 *   main format field (upper 8 bits)
 *   sub format field (lower 24 bits).
 *
 * The main format indicates the main codec type. The sub format field indicates
 * options and parameters for each format. The sub format is mainly used for
 * record to indicate for instance the requested bitrate or profile.  It can
 * also be used for certain formats to give informations not present in the
 * encoded audio stream (e.g. octet alignement for AMR).
 */
@export(name="audio_format_t")
enum AudioFormat : uint32_t {
    AUDIO_FORMAT_INVALID             = 0xFFFFFFFFUL,
    AUDIO_FORMAT_DEFAULT             = 0,
    AUDIO_FORMAT_PCM                 = 0x00000000UL, /* DO NOT CHANGE */
    AUDIO_FORMAT_MP3                 = 0x01000000UL,
    AUDIO_FORMAT_AMR_NB              = 0x02000000UL,
    AUDIO_FORMAT_AMR_WB              = 0x03000000UL,
    AUDIO_FORMAT_AAC                 = 0x04000000UL,
    /* Deprecated, Use AUDIO_FORMAT_AAC_HE_V1*/
    AUDIO_FORMAT_HE_AAC_V1           = 0x05000000UL,
    /* Deprecated, Use AUDIO_FORMAT_AAC_HE_V2*/
    AUDIO_FORMAT_HE_AAC_V2           = 0x06000000UL,
    AUDIO_FORMAT_VORBIS              = 0x07000000UL,
    AUDIO_FORMAT_OPUS                = 0x08000000UL,
    AUDIO_FORMAT_AC3                 = 0x09000000UL,
    AUDIO_FORMAT_E_AC3               = 0x0A000000UL,
    AUDIO_FORMAT_DTS                 = 0x0B000000UL,
    AUDIO_FORMAT_DTS_HD              = 0x0C000000UL,
    // IEC61937 is encoded audio wrapped in 16-bit PCM.
    AUDIO_FORMAT_IEC61937            = 0x0D000000UL,
    AUDIO_FORMAT_DOLBY_TRUEHD        = 0x0E000000UL,
    AUDIO_FORMAT_MAIN_MASK           = 0xFF000000UL, /* Deprecated */
    AUDIO_FORMAT_SUB_MASK            = 0x00FFFFFFUL,

    /* Subformats */
    AUDIO_FORMAT_PCM_SUB_16_BIT        = 0x1, // PCM signed 16 bits
    AUDIO_FORMAT_PCM_SUB_8_BIT         = 0x2, // PCM unsigned 8 bits
    AUDIO_FORMAT_PCM_SUB_32_BIT        = 0x3, // PCM signed .31 fixed point
    AUDIO_FORMAT_PCM_SUB_8_24_BIT      = 0x4, // PCM signed 8.23 fixed point
    AUDIO_FORMAT_PCM_SUB_FLOAT         = 0x5, // PCM single-precision float pt
    AUDIO_FORMAT_PCM_SUB_24_BIT_PACKED = 0x6, // PCM signed .23 fix pt (3 bytes)

    AUDIO_FORMAT_MP3_SUB_NONE          = 0x0,

    AUDIO_FORMAT_AMR_SUB_NONE          = 0x0,

    AUDIO_FORMAT_AAC_SUB_MAIN          = 0x1,
    AUDIO_FORMAT_AAC_SUB_LC            = 0x2,
    AUDIO_FORMAT_AAC_SUB_SSR           = 0x4,
    AUDIO_FORMAT_AAC_SUB_LTP           = 0x8,
    AUDIO_FORMAT_AAC_SUB_HE_V1         = 0x10,
    AUDIO_FORMAT_AAC_SUB_SCALABLE      = 0x20,
    AUDIO_FORMAT_AAC_SUB_ERLC          = 0x40,
    AUDIO_FORMAT_AAC_SUB_LD            = 0x80,
    AUDIO_FORMAT_AAC_SUB_HE_V2         = 0x100,
    AUDIO_FORMAT_AAC_SUB_ELD           = 0x200,

    AUDIO_FORMAT_VORBIS_SUB_NONE       = 0x0,

    /* Aliases */
    /* note != AudioFormat.ENCODING_PCM_16BIT */
    AUDIO_FORMAT_PCM_16_BIT          = (AUDIO_FORMAT_PCM |
                                        AUDIO_FORMAT_PCM_SUB_16_BIT),
    /* note != AudioFormat.ENCODING_PCM_8BIT */
    AUDIO_FORMAT_PCM_8_BIT           = (AUDIO_FORMAT_PCM |
                                        AUDIO_FORMAT_PCM_SUB_8_BIT),
    AUDIO_FORMAT_PCM_32_BIT          = (AUDIO_FORMAT_PCM |
                                        AUDIO_FORMAT_PCM_SUB_32_BIT),
    AUDIO_FORMAT_PCM_8_24_BIT        = (AUDIO_FORMAT_PCM |
                                        AUDIO_FORMAT_PCM_SUB_8_24_BIT),
    AUDIO_FORMAT_PCM_FLOAT           = (AUDIO_FORMAT_PCM |
                                        AUDIO_FORMAT_PCM_SUB_FLOAT),
    AUDIO_FORMAT_PCM_24_BIT_PACKED   = (AUDIO_FORMAT_PCM |
                                        AUDIO_FORMAT_PCM_SUB_24_BIT_PACKED),
    AUDIO_FORMAT_AAC_MAIN            = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_MAIN),
    AUDIO_FORMAT_AAC_LC              = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_LC),
    AUDIO_FORMAT_AAC_SSR             = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_SSR),
    AUDIO_FORMAT_AAC_LTP             = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_LTP),
    AUDIO_FORMAT_AAC_HE_V1           = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_HE_V1),
    AUDIO_FORMAT_AAC_SCALABLE        = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_SCALABLE),
    AUDIO_FORMAT_AAC_ERLC            = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_ERLC),
    AUDIO_FORMAT_AAC_LD              = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_LD),
    AUDIO_FORMAT_AAC_HE_V2           = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_HE_V2),
    AUDIO_FORMAT_AAC_ELD             = (AUDIO_FORMAT_AAC |
                                        AUDIO_FORMAT_AAC_SUB_ELD)
};

/*
 * Usage of these values highlights places in the code that use 2- or 8- channel
 * assumptions.
 */
@export(name="")
enum FixedChannelCount {
    FCC_2 = 2, // This is typically due to legacy implementation of stereo I/O
    FCC_8 = 8  // This is typically due to audio mixer and resampler limitations
};

/*
 * A channel mask per se only defines the presence or absence of a channel, not
 * the order.  See AUDIO_INTERLEAVE_* for the platform convention of order.
 *
 * AudioChannelMask is an opaque type and its internal layout should not be
 * assumed as it may change in the future.  Instead, always use functions
 * to examine it.
 *
 * These are the current representations:
 *
 *   AUDIO_CHANNEL_REPRESENTATION_POSITION
 *     is a channel mask representation for position assignment.  Each low-order
 *     bit corresponds to the spatial position of a transducer (output), or
 *     interpretation of channel (input).  The user of a channel mask needs to
 *     know the context of whether it is for output or input.  The constants
 *     AUDIO_CHANNEL_OUT_* or AUDIO_CHANNEL_IN_* apply to the bits portion.  It
 *     is not permitted for no bits to be set.
 *
 *   AUDIO_CHANNEL_REPRESENTATION_INDEX
 *     is a channel mask representation for index assignment.  Each low-order
 *     bit corresponds to a selected channel.  There is no platform
 *     interpretation of the various bits.  There is no concept of output or
 *     input.  It is not permitted for no bits to be set.
 *
 * All other representations are reserved for future use.
 *
 * Warning: current representation distinguishes between input and output, but
 * this will not the be case in future revisions of the platform. Wherever there
 * is an ambiguity between input and output that is currently resolved by
 * checking the channel mask, the implementer should look for ways to fix it
 * with additional information outside of the mask.
 */
@export(name="")
enum AudioChannelMask : uint32_t {
    AUDIO_CHANNEL_REPRESENTATION_POSITION = 0, /* must be 0 for compatibility */
    /* 1 is reserved for future use */
    AUDIO_CHANNEL_REPRESENTATION_INDEX    = 2,
    /* 3 is reserved for future use */

    /* These can be a complete value of AudioChannelMask */
    AUDIO_CHANNEL_NONE                      = 0x0,
    AUDIO_CHANNEL_INVALID                   = 0xC0000000,

   /*
    * These can be the bits portion of an AudioChannelMask
    * with representation AUDIO_CHANNEL_REPRESENTATION_POSITION.
    */

    /* output channels */
    AUDIO_CHANNEL_OUT_FRONT_LEFT            = 0x1,
    AUDIO_CHANNEL_OUT_FRONT_RIGHT           = 0x2,
    AUDIO_CHANNEL_OUT_FRONT_CENTER          = 0x4,
    AUDIO_CHANNEL_OUT_LOW_FREQUENCY         = 0x8,
    AUDIO_CHANNEL_OUT_BACK_LEFT             = 0x10,
    AUDIO_CHANNEL_OUT_BACK_RIGHT            = 0x20,
    AUDIO_CHANNEL_OUT_FRONT_LEFT_OF_CENTER  = 0x40,
    AUDIO_CHANNEL_OUT_FRONT_RIGHT_OF_CENTER = 0x80,
    AUDIO_CHANNEL_OUT_BACK_CENTER           = 0x100,
    AUDIO_CHANNEL_OUT_SIDE_LEFT             = 0x200,
    AUDIO_CHANNEL_OUT_SIDE_RIGHT            = 0x400,
    AUDIO_CHANNEL_OUT_TOP_CENTER            = 0x800,
    AUDIO_CHANNEL_OUT_TOP_FRONT_LEFT        = 0x1000,
    AUDIO_CHANNEL_OUT_TOP_FRONT_CENTER      = 0x2000,
    AUDIO_CHANNEL_OUT_TOP_FRONT_RIGHT       = 0x4000,
    AUDIO_CHANNEL_OUT_TOP_BACK_LEFT         = 0x8000,
    AUDIO_CHANNEL_OUT_TOP_BACK_CENTER       = 0x10000,
    AUDIO_CHANNEL_OUT_TOP_BACK_RIGHT        = 0x20000,

    AUDIO_CHANNEL_OUT_MONO     = AUDIO_CHANNEL_OUT_FRONT_LEFT,
    AUDIO_CHANNEL_OUT_STEREO   = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT),
    AUDIO_CHANNEL_OUT_QUAD     = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                                  AUDIO_CHANNEL_OUT_BACK_LEFT |
                                  AUDIO_CHANNEL_OUT_BACK_RIGHT),
    AUDIO_CHANNEL_OUT_QUAD_BACK = AUDIO_CHANNEL_OUT_QUAD,
    /* like AUDIO_CHANNEL_OUT_QUAD_BACK with *_SIDE_* instead of *_BACK_* */
    AUDIO_CHANNEL_OUT_QUAD_SIDE = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                                  AUDIO_CHANNEL_OUT_SIDE_LEFT |
                                  AUDIO_CHANNEL_OUT_SIDE_RIGHT),
    AUDIO_CHANNEL_OUT_5POINT1  = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                                  AUDIO_CHANNEL_OUT_FRONT_CENTER |
                                  AUDIO_CHANNEL_OUT_LOW_FREQUENCY |
                                  AUDIO_CHANNEL_OUT_BACK_LEFT |
                                  AUDIO_CHANNEL_OUT_BACK_RIGHT),
    AUDIO_CHANNEL_OUT_5POINT1_BACK = AUDIO_CHANNEL_OUT_5POINT1,
    /* like AUDIO_CHANNEL_OUT_5POINT1_BACK with *_SIDE_* instead of *_BACK_* */
    AUDIO_CHANNEL_OUT_5POINT1_SIDE = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                                  AUDIO_CHANNEL_OUT_FRONT_CENTER |
                                  AUDIO_CHANNEL_OUT_LOW_FREQUENCY |
                                  AUDIO_CHANNEL_OUT_SIDE_LEFT |
                                  AUDIO_CHANNEL_OUT_SIDE_RIGHT),
    /* matches the correct AudioFormat.CHANNEL_OUT_7POINT1_SURROUND */
    AUDIO_CHANNEL_OUT_7POINT1  = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                                  AUDIO_CHANNEL_OUT_FRONT_CENTER |
                                  AUDIO_CHANNEL_OUT_LOW_FREQUENCY |
                                  AUDIO_CHANNEL_OUT_BACK_LEFT |
                                  AUDIO_CHANNEL_OUT_BACK_RIGHT |
                                  AUDIO_CHANNEL_OUT_SIDE_LEFT |
                                  AUDIO_CHANNEL_OUT_SIDE_RIGHT),
    AUDIO_CHANNEL_OUT_ALL      = (AUDIO_CHANNEL_OUT_FRONT_LEFT |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                                  AUDIO_CHANNEL_OUT_FRONT_CENTER |
                                  AUDIO_CHANNEL_OUT_LOW_FREQUENCY |
                                  AUDIO_CHANNEL_OUT_BACK_LEFT |
                                  AUDIO_CHANNEL_OUT_BACK_RIGHT |
                                  AUDIO_CHANNEL_OUT_FRONT_LEFT_OF_CENTER |
                                  AUDIO_CHANNEL_OUT_FRONT_RIGHT_OF_CENTER |
                                  AUDIO_CHANNEL_OUT_BACK_CENTER|
                                  AUDIO_CHANNEL_OUT_SIDE_LEFT|
                                  AUDIO_CHANNEL_OUT_SIDE_RIGHT|
                                  AUDIO_CHANNEL_OUT_TOP_CENTER|
                                  AUDIO_CHANNEL_OUT_TOP_FRONT_LEFT|
                                  AUDIO_CHANNEL_OUT_TOP_FRONT_CENTER|
                                  AUDIO_CHANNEL_OUT_TOP_FRONT_RIGHT|
                                  AUDIO_CHANNEL_OUT_TOP_BACK_LEFT|
                                  AUDIO_CHANNEL_OUT_TOP_BACK_CENTER|
                                  AUDIO_CHANNEL_OUT_TOP_BACK_RIGHT),

    /* These are bits only, not complete values */

    /* input channels */
    AUDIO_CHANNEL_IN_LEFT            = 0x4,
    AUDIO_CHANNEL_IN_RIGHT           = 0x8,
    AUDIO_CHANNEL_IN_FRONT           = 0x10,
    AUDIO_CHANNEL_IN_BACK            = 0x20,
    AUDIO_CHANNEL_IN_LEFT_PROCESSED  = 0x40,
    AUDIO_CHANNEL_IN_RIGHT_PROCESSED = 0x80,
    AUDIO_CHANNEL_IN_FRONT_PROCESSED = 0x100,
    AUDIO_CHANNEL_IN_BACK_PROCESSED  = 0x200,
    AUDIO_CHANNEL_IN_PRESSURE        = 0x400,
    AUDIO_CHANNEL_IN_X_AXIS          = 0x800,
    AUDIO_CHANNEL_IN_Y_AXIS          = 0x1000,
    AUDIO_CHANNEL_IN_Z_AXIS          = 0x2000,
    AUDIO_CHANNEL_IN_VOICE_UPLINK    = 0x4000,
    AUDIO_CHANNEL_IN_VOICE_DNLINK    = 0x8000,

    AUDIO_CHANNEL_IN_MONO   = AUDIO_CHANNEL_IN_FRONT,
    AUDIO_CHANNEL_IN_STEREO = (AUDIO_CHANNEL_IN_LEFT | AUDIO_CHANNEL_IN_RIGHT),
    AUDIO_CHANNEL_IN_FRONT_BACK = (AUDIO_CHANNEL_IN_FRONT |
                                   AUDIO_CHANNEL_IN_BACK),
    AUDIO_CHANNEL_IN_ALL    = (AUDIO_CHANNEL_IN_LEFT |
                               AUDIO_CHANNEL_IN_RIGHT |
                               AUDIO_CHANNEL_IN_FRONT |
                               AUDIO_CHANNEL_IN_BACK|
                               AUDIO_CHANNEL_IN_LEFT_PROCESSED |
                               AUDIO_CHANNEL_IN_RIGHT_PROCESSED |
                               AUDIO_CHANNEL_IN_FRONT_PROCESSED |
                               AUDIO_CHANNEL_IN_BACK_PROCESSED|
                               AUDIO_CHANNEL_IN_PRESSURE |
                               AUDIO_CHANNEL_IN_X_AXIS |
                               AUDIO_CHANNEL_IN_Y_AXIS |
                               AUDIO_CHANNEL_IN_Z_AXIS |
                               AUDIO_CHANNEL_IN_VOICE_UPLINK |
                               AUDIO_CHANNEL_IN_VOICE_DNLINK),

    /*
     * Expresses the convention when stereo audio samples are stored interleaved
     * in an array.  This should improve readability by allowing code to use
     * symbolic indices instead of hard-coded [0] and [1].
     *
     * For multi-channel beyond stereo, the platform convention is that channels
     * are interleaved in order from least significant channel mask bit to most
     * significant channel mask bit, with unused bits skipped.  Any exceptions
     * to this convention will be noted at the appropriate API.
     */
    AUDIO_INTERLEAVE_LEFT   = 0,
    AUDIO_INTERLEAVE_RIGHT  = 1,

    AUDIO_CHANNEL_COUNT_MAX  = 30,
    AUDIO_CHANNEL_INDEX_HDR  =
        AUDIO_CHANNEL_REPRESENTATION_INDEX << AUDIO_CHANNEL_COUNT_MAX,
    AUDIO_CHANNEL_INDEX_MASK_1 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 1) - 1),
    AUDIO_CHANNEL_INDEX_MASK_2 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 2) - 1),
    AUDIO_CHANNEL_INDEX_MASK_3 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 3) - 1),
    AUDIO_CHANNEL_INDEX_MASK_4 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 4) - 1),
    AUDIO_CHANNEL_INDEX_MASK_5 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 5) - 1),
    AUDIO_CHANNEL_INDEX_MASK_6 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 6) - 1),
    AUDIO_CHANNEL_INDEX_MASK_7 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 7) - 1),
    AUDIO_CHANNEL_INDEX_MASK_8 =  AUDIO_CHANNEL_INDEX_HDR | ((1 << 8) - 1)
};

/*
 * Major modes for a mobile device. The current mode setting affects audio
 * routing.
 */
@export(name="audio_mode_t")
enum AudioMode {
    AUDIO_MODE_INVALID          = -2,
    AUDIO_MODE_CURRENT          = -1,
    AUDIO_MODE_NORMAL           = 0,
    AUDIO_MODE_RINGTONE         = 1,
    AUDIO_MODE_IN_CALL          = 2,
    AUDIO_MODE_IN_COMMUNICATION = 3,

    AUDIO_MODE_CNT,
    AUDIO_MODE_MAX              = AUDIO_MODE_CNT - 1,
};

@export(name="")
enum AudioDevice : uint32_t {
    AUDIO_DEVICE_NONE                          = 0x0,
    /* reserved bits */
    AUDIO_DEVICE_BIT_IN                        = 0x80000000,
    AUDIO_DEVICE_BIT_DEFAULT                   = 0x40000000,
    /* output devices */
    AUDIO_DEVICE_OUT_EARPIECE                  = 0x1,
    AUDIO_DEVICE_OUT_SPEAKER                   = 0x2,
    AUDIO_DEVICE_OUT_WIRED_HEADSET             = 0x4,
    AUDIO_DEVICE_OUT_WIRED_HEADPHONE           = 0x8,
    AUDIO_DEVICE_OUT_BLUETOOTH_SCO             = 0x10,
    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET     = 0x20,
    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT      = 0x40,
    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP            = 0x80,
    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100,
    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER    = 0x200,
    AUDIO_DEVICE_OUT_AUX_DIGITAL               = 0x400,
    AUDIO_DEVICE_OUT_HDMI                      = AUDIO_DEVICE_OUT_AUX_DIGITAL,
    /* uses an analog connection (multiplexed over the USB pins for instance) */
    AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET         = 0x800,
    AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET         = 0x1000,
    /* USB accessory mode: Android device is USB device and dock is USB host */
    AUDIO_DEVICE_OUT_USB_ACCESSORY             = 0x2000,
    /* USB host mode: Android device is USB host and dock is USB device */
    AUDIO_DEVICE_OUT_USB_DEVICE                = 0x4000,
    AUDIO_DEVICE_OUT_REMOTE_SUBMIX             = 0x8000,
    /* Telephony voice TX path */
    AUDIO_DEVICE_OUT_TELEPHONY_TX              = 0x10000,
    /* Analog jack with line impedance detected */
    AUDIO_DEVICE_OUT_LINE                      = 0x20000,
    /* HDMI Audio Return Channel */
    AUDIO_DEVICE_OUT_HDMI_ARC                  = 0x40000,
    /* S/PDIF out */
    AUDIO_DEVICE_OUT_SPDIF                     = 0x80000,
    /* FM transmitter out */
    AUDIO_DEVICE_OUT_FM                        = 0x100000,
    /* Line out for av devices */
    AUDIO_DEVICE_OUT_AUX_LINE                  = 0x200000,
    /* limited-output speaker device for acoustic safety */
    AUDIO_DEVICE_OUT_SPEAKER_SAFE              = 0x400000,
    AUDIO_DEVICE_OUT_IP                        = 0x800000,
    /* audio bus implemented by the audio system (e.g an MOST stereo channel) */
    AUDIO_DEVICE_OUT_BUS                       = 0x1000000,
    AUDIO_DEVICE_OUT_DEFAULT                   = AUDIO_DEVICE_BIT_DEFAULT,
    AUDIO_DEVICE_OUT_ALL      = (AUDIO_DEVICE_OUT_EARPIECE |
                                 AUDIO_DEVICE_OUT_SPEAKER |
                                 AUDIO_DEVICE_OUT_WIRED_HEADSET |
                                 AUDIO_DEVICE_OUT_WIRED_HEADPHONE |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_SCO |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_A2DP |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER |
                                 AUDIO_DEVICE_OUT_HDMI |
                                 AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET |
                                 AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET |
                                 AUDIO_DEVICE_OUT_USB_ACCESSORY |
                                 AUDIO_DEVICE_OUT_USB_DEVICE |
                                 AUDIO_DEVICE_OUT_REMOTE_SUBMIX |
                                 AUDIO_DEVICE_OUT_TELEPHONY_TX |
                                 AUDIO_DEVICE_OUT_LINE |
                                 AUDIO_DEVICE_OUT_HDMI_ARC |
                                 AUDIO_DEVICE_OUT_SPDIF |
                                 AUDIO_DEVICE_OUT_FM |
                                 AUDIO_DEVICE_OUT_AUX_LINE |
                                 AUDIO_DEVICE_OUT_SPEAKER_SAFE |
                                 AUDIO_DEVICE_OUT_IP |
                                 AUDIO_DEVICE_OUT_BUS |
                                 AUDIO_DEVICE_OUT_DEFAULT),
    AUDIO_DEVICE_OUT_ALL_A2DP = (AUDIO_DEVICE_OUT_BLUETOOTH_A2DP |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER),
    AUDIO_DEVICE_OUT_ALL_SCO  = (AUDIO_DEVICE_OUT_BLUETOOTH_SCO |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
                                 AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT),
    AUDIO_DEVICE_OUT_ALL_USB  = (AUDIO_DEVICE_OUT_USB_ACCESSORY |
                                 AUDIO_DEVICE_OUT_USB_DEVICE),
    /* input devices */
    AUDIO_DEVICE_IN_COMMUNICATION         = AUDIO_DEVICE_BIT_IN | 0x1,
    AUDIO_DEVICE_IN_AMBIENT               = AUDIO_DEVICE_BIT_IN | 0x2,
    AUDIO_DEVICE_IN_BUILTIN_MIC           = AUDIO_DEVICE_BIT_IN | 0x4,
    AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET = AUDIO_DEVICE_BIT_IN | 0x8,
    AUDIO_DEVICE_IN_WIRED_HEADSET         = AUDIO_DEVICE_BIT_IN | 0x10,
    AUDIO_DEVICE_IN_AUX_DIGITAL           = AUDIO_DEVICE_BIT_IN | 0x20,
    AUDIO_DEVICE_IN_HDMI                  = AUDIO_DEVICE_IN_AUX_DIGITAL,
    /* Telephony voice RX path */
    AUDIO_DEVICE_IN_VOICE_CALL            = AUDIO_DEVICE_BIT_IN | 0x40,
    AUDIO_DEVICE_IN_TELEPHONY_RX          = AUDIO_DEVICE_IN_VOICE_CALL,
    AUDIO_DEVICE_IN_BACK_MIC              = AUDIO_DEVICE_BIT_IN | 0x80,
    AUDIO_DEVICE_IN_REMOTE_SUBMIX         = AUDIO_DEVICE_BIT_IN | 0x100,
    AUDIO_DEVICE_IN_ANLG_DOCK_HEADSET     = AUDIO_DEVICE_BIT_IN | 0x200,
    AUDIO_DEVICE_IN_DGTL_DOCK_HEADSET     = AUDIO_DEVICE_BIT_IN | 0x400,
    AUDIO_DEVICE_IN_USB_ACCESSORY         = AUDIO_DEVICE_BIT_IN | 0x800,
    AUDIO_DEVICE_IN_USB_DEVICE            = AUDIO_DEVICE_BIT_IN | 0x1000,
    /* FM tuner input */
    AUDIO_DEVICE_IN_FM_TUNER              = AUDIO_DEVICE_BIT_IN | 0x2000,
    /* TV tuner input */
    AUDIO_DEVICE_IN_TV_TUNER              = AUDIO_DEVICE_BIT_IN | 0x4000,
    /* Analog jack with line impedance detected */
    AUDIO_DEVICE_IN_LINE                  = AUDIO_DEVICE_BIT_IN | 0x8000,
    /* S/PDIF in */
    AUDIO_DEVICE_IN_SPDIF                 = AUDIO_DEVICE_BIT_IN | 0x10000,
    AUDIO_DEVICE_IN_BLUETOOTH_A2DP        = AUDIO_DEVICE_BIT_IN | 0x20000,
    AUDIO_DEVICE_IN_LOOPBACK              = AUDIO_DEVICE_BIT_IN | 0x40000,
    AUDIO_DEVICE_IN_IP                    = AUDIO_DEVICE_BIT_IN | 0x80000,
    /* audio bus implemented by the audio system (e.g an MOST stereo channel) */
    AUDIO_DEVICE_IN_BUS                   = AUDIO_DEVICE_BIT_IN | 0x100000,
    AUDIO_DEVICE_IN_DEFAULT               = AUDIO_DEVICE_BIT_IN |
                                            AUDIO_DEVICE_BIT_DEFAULT,

    AUDIO_DEVICE_IN_ALL     = (AUDIO_DEVICE_IN_COMMUNICATION |
                               AUDIO_DEVICE_IN_AMBIENT |
                               AUDIO_DEVICE_IN_BUILTIN_MIC |
                               AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET |
                               AUDIO_DEVICE_IN_WIRED_HEADSET |
                               AUDIO_DEVICE_IN_HDMI |
                               AUDIO_DEVICE_IN_TELEPHONY_RX |
                               AUDIO_DEVICE_IN_BACK_MIC |
                               AUDIO_DEVICE_IN_REMOTE_SUBMIX |
                               AUDIO_DEVICE_IN_ANLG_DOCK_HEADSET |
                               AUDIO_DEVICE_IN_DGTL_DOCK_HEADSET |
                               AUDIO_DEVICE_IN_USB_ACCESSORY |
                               AUDIO_DEVICE_IN_USB_DEVICE |
                               AUDIO_DEVICE_IN_FM_TUNER |
                               AUDIO_DEVICE_IN_TV_TUNER |
                               AUDIO_DEVICE_IN_LINE |
                               AUDIO_DEVICE_IN_SPDIF |
                               AUDIO_DEVICE_IN_BLUETOOTH_A2DP |
                               AUDIO_DEVICE_IN_LOOPBACK |
                               AUDIO_DEVICE_IN_IP |
                               AUDIO_DEVICE_IN_BUS |
                               AUDIO_DEVICE_IN_DEFAULT),
    AUDIO_DEVICE_IN_ALL_SCO = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET,
    AUDIO_DEVICE_IN_ALL_USB  = (AUDIO_DEVICE_IN_USB_ACCESSORY |
                                AUDIO_DEVICE_IN_USB_DEVICE),
};

/*
 * The audio output flags serve two purposes:
 *
 *  - when an AudioTrack is created they indicate a "wish" to be connected to an
 *    output stream with attributes corresponding to the specified flags;
 *
 *  - when present in an output profile descriptor listed for a particular audio
 *    hardware module, they indicate that an output stream can be opened that
 *    supports the attributes indicated by the flags.
 *
 * The audio policy manager will try to match the flags in the request
 * (when getOuput() is called) to an available output stream.
 */
@export(name="audio_output_flags_t")
enum AudioOutputFlag {
    AUDIO_OUTPUT_FLAG_NONE = 0x0,    // no attributes
    AUDIO_OUTPUT_FLAG_DIRECT = 0x1,  // this output directly connects a track
                                     // to one output stream: no software mixer
    AUDIO_OUTPUT_FLAG_PRIMARY = 0x2, // this output is the primary output of
                                     // the device. It is unique and must be
                                     // present. It is opened by default and
                                     // receives routing, audio mode and volume
                                     // controls related to voice calls.
    AUDIO_OUTPUT_FLAG_FAST = 0x4,    // output supports "fast tracks",
                                     // defined elsewhere
    AUDIO_OUTPUT_FLAG_DEEP_BUFFER = 0x8, // use deep audio buffers
    AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD = 0x10, // offload playback of compressed
                                               // streams to hardware codec
    AUDIO_OUTPUT_FLAG_NON_BLOCKING = 0x20, // use non-blocking write
    AUDIO_OUTPUT_FLAG_HW_AV_SYNC = 0x40,   // output uses a hardware A/V sync
    AUDIO_OUTPUT_FLAG_TTS = 0x80,   // output for streams transmitted through
                                    // speaker at a sample rate high enough
                                    // to accommodate lower-range ultrasonic p/b
    AUDIO_OUTPUT_FLAG_RAW = 0x100,  // minimize signal processing
    AUDIO_OUTPUT_FLAG_SYNC = 0x200, // synchronize I/O streams
    AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO = 0x400, // Audio stream contains
                                               // compressed audio in
                                               // SPDIF data bursts, not PCM.
};

/*
 * The audio input flags are analogous to audio output flags.
 * Currently they are used only when an AudioRecord is created,
 * to indicate a preference to be connected to an input stream with
 * attributes corresponding to the specified flags.
 */
@export(name="audio_input_flags_t")
enum AudioInputFlags {
    AUDIO_INPUT_FLAG_NONE       = 0x0,  // no attributes
    AUDIO_INPUT_FLAG_FAST       = 0x1,  // prefer an input that supports
                                        // "fast tracks"
    AUDIO_INPUT_FLAG_HW_HOTWORD = 0x2,  // prefer an input that captures from
                                        // hw hotword source
    AUDIO_INPUT_FLAG_RAW        = 0x4,  // minimize signal processing
    AUDIO_INPUT_FLAG_SYNC       = 0x8,  // synchronize I/O streams
};

/*
 * Additional information about the stream passed to hardware decoders.
 */
struct AudioOffloadInfo {
    uint32_t sampleRateHz;
    AudioChannelMask channelMask;
    AudioFormat format;
    AudioStreamType streamType;
    uint32_t bitRatePerSecond;
    int64_t durationMicroseconds;  // -1 if unknown
    bool hasVideo;
    bool isStreaming;
};

/*
 * Commonly used audio stream configuration parameters.
 */
struct AudioConfig {
    uint32_t sampleRateHz;
    AudioChannelMask channelMask;
    AudioFormat format;
    AudioOffloadInfo offloadInfo;
    uint64_t frameCount;
};


/*
 *
 *  Volume control
 *
 */

/*
 * Type of gain control exposed by an audio port.
 */
@export(name="")
enum AudioGainMode : uint32_t {
    AUDIO_GAIN_MODE_JOINT = 0x1,    // supports joint channel gain control
    AUDIO_GAIN_MODE_CHANNELS = 0x2, // supports separate channel gain control
    AUDIO_GAIN_MODE_RAMP = 0x4      // supports gain ramps
};

/*
 * An audio_gain struct is a representation of a gain stage.
 * A gain stage is always attached to an audio port.
 */
struct AudioGain {
    AudioGainMode mode;
    AudioChannelMask channelMask; // channels which gain an be controlled
    int32_t minValue;     // minimum gain value in millibels
    int32_t maxValue;     // maximum gain value in millibels
    int32_t defaultValue; // default gain value in millibels
    uint32_t stepValue;   // gain step in millibels
    uint32_t minRampMs;   // minimum ramp duration in ms
    uint32_t maxRampMs;   // maximum ramp duration in ms
};

/*
 * The gain configuration structure is used to get or set the gain values of a
 * given port.
 */
struct AudioGainConfig {
    int32_t index;  // index of the corresponding AudioGain in AudioPort.gains
    AudioGainMode mode;
    AudioChannelMask channelMask;  // channels which gain value follows
    /*
     * 4 = sizeof(AudioChannelMask),
     * 8 is not "FCC_8", so it won't need to be changed for > 8 channels.
     * Gain values in millibels for each channel ordered from LSb to MSb in
     * channel mask. The number of values is 1 in joint mode or
     * popcount(channel_mask).
     */
    int32_t[4 * 8] values;
    uint32_t rampDurationMs;  // ramp duration in ms
};


/*
 *
 *  Routing control
 *
 */

/*
 * Types defined here are used to describe an audio source or sink at internal
 * framework interfaces (audio policy, patch panel) or at the audio HAL.
 * Sink and sources are grouped in a concept of “audio port” representing an
 * audio end point at the edge of the system managed by the module exposing
 * the interface.
 */

/* Audio port role: either source or sink */
@export(name="audio_port_role_t")
enum AudioPortRole {
    AUDIO_PORT_ROLE_NONE,
    AUDIO_PORT_ROLE_SOURCE,
    AUDIO_PORT_ROLE_SINK,
};

/*
 * Audio port type indicates if it is a session (e.g AudioTrack),
 * a mix (e.g PlaybackThread output) or a physical device
 * (e.g AUDIO_DEVICE_OUT_SPEAKER)
 */
@export(name="audio_port_type_t")
enum AudioPortType {
    AUDIO_PORT_TYPE_NONE,
    AUDIO_PORT_TYPE_DEVICE,
    AUDIO_PORT_TYPE_MIX,
    AUDIO_PORT_TYPE_SESSION,
};

/*
 * Extension for audio port configuration structure when the audio port is a
 * hardware device.
 */
struct AudioPortConfigDeviceExt {
    AudioModuleHandle hwModule;  // module the device is attached to
    AudioDevice type;            // device type (e.g AUDIO_DEVICE_OUT_SPEAKER)
    uint8_t[32] address;         // device address. "" if N/A
};

/*
 * Extension for audio port configuration structure when the audio port is an
 * audio session.
 */
struct AudioPortConfigSessionExt {
    AudioSession session;
};

/*
 * Flags indicating which fields are to be considered in AudioPortConfig.
 */
@export(name="")
enum AudioPortConfigMask : uint32_t {
    AUDIO_PORT_CONFIG_SAMPLE_RATE = 0x1,
    AUDIO_PORT_CONFIG_CHANNEL_MASK =  0x2,
    AUDIO_PORT_CONFIG_FORMAT = 0x4,
    AUDIO_PORT_CONFIG_GAIN = 0x8,
    AUDIO_PORT_CONFIG_ALL = AUDIO_PORT_CONFIG_SAMPLE_RATE |
                            AUDIO_PORT_CONFIG_CHANNEL_MASK |
                            AUDIO_PORT_CONFIG_FORMAT |
                            AUDIO_PORT_CONFIG_GAIN
};

/*
 * Audio port configuration structure used to specify a particular configuration
 * of an audio port.
 */
struct AudioPortConfig {
    AudioPortHandle id;
    AudioPortConfigMask configMask;
    uint32_t sampleRateHz;
    AudioChannelMask channelMask;
    AudioFormat format;
    AudioGainConfig gain;
    AudioPortType type;  // type is used as a discriminator for Ext union
    AudioPortRole role;  // role is used as a discriminator for UseCase union
    union Ext {
        AudioPortConfigDeviceExt device;
        struct AudioPortConfigMixExt {
            AudioModuleHandle hwModule; // module the stream is attached to
            AudioIoHandle ioHandle;     // I/O handle of the input/output stream
            union UseCase {
                AudioStreamType stream;
                AudioSource source;
            };
        } mix;
        AudioPortConfigSessionExt session;
    };
};

/*
 * Extension for audio port structure when the audio port is a hardware device.
 */
struct AudioPortDeviceExt {
    AudioModuleHandle hwModule;    // module the device is attached to
    AudioDevice type;
    uint8_t[32] address;
};

/*
 * Latency class of the audio mix.
 */
@export(name="audio_mix_latency_class_t")
enum AudioMixLatencyClass {
    AUDIO_LATENCY_LOW,
    AUDIO_LATENCY_NORMAL
} ;

struct AudioPortMixExt {
    AudioModuleHandle hwModule;     // module the stream is attached to
    AudioIoHandle ioHandle;         // I/O handle of the stream
    AudioMixLatencyClass latencyClass;
};

/*
 * Extension for audio port structure when the audio port is an audio session.
 */
struct AudioPortSessionExt {
    AudioSession session;
};

struct AudioPort {
    AudioPortHandle id;
    AudioPortRole role;
    string name;
    vec<uint32_t> sampleRates;
    vec<AudioChannelMask> channelMasks;
    vec<AudioFormat> formats;
    vec<AudioGain> gains;
    AudioPortConfig activeConfig; // current audio port configuration
    AudioPortType type;  // type is used as a discriminator
    union Ext {
        AudioPortDeviceExt device;
        AudioPortMixExt mix;
        AudioPortSessionExt session;
    };
};

/*
 * An audio patch represents a connection between one or more source ports and
 * one or more sink ports. Patches are connected and disconnected by audio
 * policy manager or by applications via framework APIs.
 */
struct AudioPatch {
    AudioPatchHandle id;
    vec<AudioPortConfig> sources;
    vec<AudioPortConfig> sinks;
};
