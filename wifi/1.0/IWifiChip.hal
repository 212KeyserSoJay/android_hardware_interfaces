/*
 * Copyright 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.wifi@1.0;

import IWifiChipEventCallback;
import IWifiApIface;
import IWifiNanIface;
import IWifiP2pIface;
import IWifiStaIface;

/**
 * Interface that represents a chip that must be configured as a single unit.
 * The HAL/driver/firmware will be responsible for determining which phy is used
 * to perform operations like NAN, RTT, etc.
 */
interface IWifiChip {
  /**
   * Set of interface types with the maximum number of interfaces that can have
   * one of the specified type for a given ChipIfaceCombination. See
   * ChipIfaceCombination for examples.
   */
  struct ChipIfaceCombinationLimit {
    vec<IfaceType> types; // Each IfaceType may occur at most once
    uint32_t maxIfaces;
  };

  /**
   * Set of interfaces that can operate concurrently when in a given mode. See
   * ChipMode below.
   *
   * For example:
   *   [{STA} <= 2]
   *       At most two STA interfaces are supported
   *       [], [STA], [STA+STA]
   *
   *   [{STA} <= 1, {NAN} <= 1, {AP} <= 1]
   *       Any combination of STA, NAN, AP
   *       [], [STA], [NAN], [AP], [STA+NAN], [STA+AP], [NAN+AP], [STA+NAN+AP]
   *
   *   [{STA} <= 1, {NAN,P2P} <= 1]
   *       Optionally a STA and either NAN or P2P
   *       [], [STA], [STA+NAN], [STA+P2P], [NAN], [P2P]
   *       Not included [NAN+P2P], [STA+NAN+P2P]
   *
   *   [{STA} <= 1, {STA,NAN} <= 1]
   *       Optionally a STA and either a second STA or a NAN
   *       [], [STA], [STA+NAN], [STA+STA], [NAN]
   *       Not included [STA+STA+NAN]
   */
  struct ChipIfaceCombination {
    vec<ChipIfaceCombinationLimit> limits;
  };

  /**
   * A mode that the chip can be put in. A mode defines a set of constraints on
   * the interfaces that can exist while in that mode. Modes define a unit of
   * configuration where all interfaces must be torn down to switch to a
   * different mode. Some HALs may only have a single mode, but an example where
   * multiple modes would be required is if a chip has different firmwares with
   * different capabilities.
   *
   * When in a mode, it must be possible to perform any combination of creating
   * and removing interfaces as long as at least one of the
   * ChipIfaceCombinations is satisfied. This means that if a chip has two
   * available combinations, [{STA} <= 1] and [{AP} <= 1] then it is expected
   * that exactly one STA interface or one AP interface can be created, but it
   * is not expected that both a STA and AP interface could be created. If it
   * was then there would be a single available combination
   * [{STA} <=1, {AP} <= 1].
   *
   * When switching between two available combinations it is expected that
   * interfaces only supported by the initial combination will be removed until
   * the target combination is also satisfied. At that point new interfaces
   * satisfying only the target combination can be added (meaning the initial
   * combination limits will no longer satisfied). The addition of these new
   * interfaces should not impact the existence of interfaces that satisfy both
   * combinations.
   *
   * For example, a chip with available combinations:
   *     [{STA} <= 2, {NAN} <=1] and [{STA} <=1, {NAN} <= 1, {AP} <= 1}]
   * If the chip currently has 3 interfaces STA, STA and NAN and wants to add an
   * AP interface in place of one of the STAs then first one of the STA
   * interfaces must be removed and then the AP interface can be created after
   * the STA had been torn down. During this process the remaining STA and NAN
   * interfaces should not be removed/recreated.
   *
   * If a chip does not support this kind of reconfiguration in this mode then
   * the combinations should be separated into two separate modes. Before
   * switching modes all interfaces will be torn down, the mode switch will be
   * enacted and when it completes the new interfaces will be brought up.
   */
  struct ChipMode {
    /**
     * Id that can be used to put the chip in this mode.
     */
    ChipModeId id;

    /**
     * A list of the possible interface combinations that the chip can have
     * while in this mode.
     */
    vec<ChipIfaceCombination> availableCombinations;
  };

  /**
   * Get the id assigned to this chip.
   *
   * @return id Assigned chip Id.
   */
  getId() generates (ChipId id);

  /**
   * Requests notifications of significant events on this chip. Multiple calls
   * to this will register multiple callbacks each of which will receive all
   * events.
   *
   * @param callback An instance of the |IWifiChipEventCallback| HIDL interface
   *        object.
   */
  oneway registerEventCallback(IWifiChipEventCallback callback);

  /**
   * Get the set of operation modes that the chip supports.
   *
   * @return modes List of modes supported by the device.
   */
  getAvailableModes() generates (vec<ChipMode> modes);

  /**
   * Reconfigure the Chip.
   * Must trigger |IWifiChipEventCallback.onChipReconfigured| on sucess,
   * or |IWifiChipEventCallback.onChipReconfigureFailure| on failure.
   *
   * @param modeId The mode that the chip should switch to, corresponding to the
   *        id property of the target ChipMode.
   */
  oneway configureChip(ChipModeId modeId);

  /**
   * Get the current mode that the chip is in.
   *
   * @return modeId The mode that the chip is currently configured to,
   *         corresponding to the id property of the target ChipMode.
   */
  getMode() generates (ChipModeId modeId);

  /**
   * Request information about the chip.
   * Must trigger |IWifiChipEventCallback.onChipDebugInfoAvailable| on sucess,
   * or |IWifiChipEventCallback.onChipDebugInfoFailure| on failure.
   */
  oneway requestChipDebugInfo();

  /**
   * Request vendor debug info from the driver.
   * Must trigger |IWifiChipEventCallback.onDriverDebugDumpAvailable| on success,
   * or |IWifiChipEventCallback.onDriverDebugDumpFailure| on failure.
   */
  oneway requestDriverDebugDump();

  /**
   * Request vendor debug info from the firmware.
   * Must trigger |IWifiChipEventCallback.onFirmwareDebugDumpAvailable| on
   * success, or |IWifiChipEventCallback.onFirmwareDebugDumpFailure| on failure.
   */
  oneway requestFirmwareDebugDump();

  /**
   * Create an AP iface on the chip.
   *
   * Depending on the mode the chip is configured in, the interface creation
   * may fail if we've already reached the maximum allowed
   * (specified in |ChipIfaceCombination|) number of ifaces of the AP type.
   *
   * @return iface HIDL interface object representing the iface if
   *         successful, null otherwise.
   */
  createApIface() generates (IWifiApIface iface);

  /**
   * List all the AP iface names configured on the chip.
   * The corresponding |IWifiApIface| object for any iface are
   * retrieved using |getApIface| method.
   *
   * @return ifnames List of all AP iface names on the chip.
   */
  getApIfaceNames() generates (vec<string> ifnames);

  /**
   * Gets a HIDL interface object for the AP Iface corresponding
   * to the provided ifname.
   *
   * @param ifname Name of the iface.
   * @return iface HIDL interface object representing the iface if
   *         it exists, null otherwise.
   */
  getApIface(string ifname) generates (IWifiApIface iface);

  /**
   * Create a NAN iface on the chip.
   *
   * Depending on the mode the chip is configured in, the interface creation
   * may fail if we've already reached the maximum allowed
   * (specified in |ChipIfaceCombination|) number of ifaces of the NAN type.
   *
   * @return iface HIDL interface object representing the iface if
   *         successful, null otherwise.
   */
  createNanIface() generates (IWifiNanIface iface);

  /**
   * List all the NAN iface names configured on the chip.
   * The corresponding |IWifiNanIface| object for any iface are
   * retrieved using |getNanIface| method.
   *
   * @return ifnames List of all NAN iface names on the chip.
   */
  getNanIfaceNames() generates (vec<string> ifnames);

  /**
   * Gets a HIDL interface object for the NAN Iface corresponding
   * to the provided ifname.
   *
   * @param ifname Name of the iface.
   * @return iface HIDL interface object representing the iface if
   *         it exists, null otherwise.
   */
  getNanIface(string ifname) generates (IWifiNanIface iface);

  /**
   * Create a P2P iface on the chip.
   *
   * Depending on the mode the chip is configured in, the interface creation
   * may fail if we've already reached the maximum allowed
   * (specified in |ChipIfaceCombination|) number of ifaces of the P2P type.
   *
   * @return iface HIDL interface object representing the iface if
   *         successful, null otherwise.
   */
  createP2pIface() generates (IWifiP2pIface iface);

  /**
   * List all the P2P iface names configured on the chip.
   * The corresponding |IWifiP2pIface| object for any iface are
   * retrieved using |getP2pIface| method.
   *
   * @return ifnames List of all P2P iface names on the chip.
   */
  getP2pIfaceNames() generates (vec<string> ifnames);

  /**
   * Gets a HIDL interface object for the P2P Iface corresponding
   * to the provided ifname.
   *
   * @param ifname Name of the iface.
   * @return iface HIDL interface object representing the iface if
   *         it exists, null otherwise.
   */
  getP2pIface(string ifname) generates (IWifiP2pIface iface);

  /**
   * Create an STA iface on the chip.
   *
   * Depending on the mode the chip is configured in, the interface creation
   * may fail if we've already reached the maximum allowed
   * (specified in |ChipIfaceCombination|) number of ifaces of the STA type.
   *
   * @return iface HIDL interface object representing the iface if
   *         successful, null otherwise.
   */
  createStaIface() generates (IWifiStaIface iface);

  /**
   * List all the STA iface names configured on the chip.
   * The corresponding |IWifiStaIface| object for any iface are
   * retrieved using |getStaIface| method.
   *
   * @return ifnames List of all STA iface names on the chip.
   */
  getStaIfaceNames() generates (vec<string> ifnames);

  /**
   * Gets a HIDL interface object for the STA Iface corresponding
   * to the provided ifname.
   *
   * @param ifname Name of the iface.
   * @return iface HIDL interface object representing the iface if
   *         it exists, null otherwise.
   */
  getStaIface(string ifname) generates (IWifiStaIface iface);
};
