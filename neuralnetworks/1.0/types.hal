/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This HAL is a work in progress */

package android.hardware.neuralnetworks@1.0;

// The types an operand can have.
// These values are the same as found in the NeuralNetworks.h and NeuralNetworksOEM.h files.
enum OperandType : uint32_t {
    FLOAT32                   = 0,
    INT32                     = 1,
    UINT32                    = 2,
    TENSOR_FLOAT32            = 3,
    TENSOR_INT32              = 4,
    TENSOR_QUANT8_ASYMM       = 5,

    OEM                       = 10000,
    TENSOR_OEM_BYTE           = 10001,
};

// The type of operations.  Unlike the operation types found in the
// NeuralNetworks.h and NeuralNetworksOEM.h files, these specify the data type they operate on.
// This is done to simplify the work of drivers.
// TODO: Currently they are the same.  Add a conversion when finalizing the model.
enum OperationType : uint32_t {
    ADD                          = 0,
    AVERAGE_POOL_2D              = 1,
    CONCATENATION                = 2,
    CONV_2D                      = 3,
    DEPTHWISE_CONV_2D            = 4,
    DEPTH_TO_SPACE               = 5,
    DEQUANTIZE                   = 6,
    EMBEDDING_LOOKUP             = 7,
    FLOOR                        = 8,
    FULLY_CONNECTED              = 9,
    HASHTABLE_LOOKUP             = 10,
    L2_NORMALIZATION             = 11,
    L2_POOL_2D                   = 12,
    LOCAL_RESPONSE_NORMALIZATION = 13,
    LOGISTIC                     = 14,
    LSH_PROJECTION               = 15,
    LSTM                         = 16,
    MAX_POOL_2D                  = 17,
    MUL                          = 18,
    RELU                         = 19,
    RELU1                        = 20,
    RELU6                        = 21,
    RESHAPE                      = 22,
    RESIZE_BILINEAR              = 23,
    RNN                          = 24,
    SOFTMAX                      = 25,
    SPACE_TO_DEPTH               = 26,
    SVDF                         = 27,
    TANH                         = 28,

    OEM_OPERATION                = 10000,
};

// Fused activation functions
enum FusedActivationFunc : int32_t {
    NONE  = 0,
    RELU  = 1,
    RELU1 = 2,
    RELU6 = 3,
};

// How an operand is used.
enum OperandLifeTime : uint32_t {
    // The operand is internal to the model.  It's created by an operation
    // and consumed by other operations.
    TEMPORARY_VARIABLE,
    // The operand is an input of the model. An operand can't be both
    // input and output of a model.
    MODEL_INPUT,
    // The operand is an output of the model.
    MODEL_OUTPUT,
    // The operand is a constant found in Model.operandValues.
    CONSTANT_COPY,
    // The operand is a constant that was specified via a Memory object.
    CONSTANT_REFERENCE
};

// Status of a device.
enum DeviceStatus : uint32_t {
    AVAILABLE,
    BUSY,
    OFFLINE,
    UNKNOWN  // Do we need this?
};

// For the reference workload
// Used by a driver to report its performance characteristics.
// TODO revisit the data types and scales.
struct PerformanceInfo {
    float execTime;    // in nanoseconds
    float powerUsage;  // in picoJoules
};

struct OperationTuple {
    // The type of operation.
    OperationType operationType;
    // The input data type of operation.
    OperandType operandType;
};

// The capabilities of a driver.
struct Capabilities {
    vec<OperationTuple> supportedOperationTuples;
    // TODO Do the same for baseline model IDs
    bool cachesCompilation;
    // TODO revisit the data types and scales.
    float bootupTime;  // in nanoseconds
    PerformanceInfo float16Performance;
    PerformanceInfo float32Performance;
    PerformanceInfo quantized8Performance;
};

// Describes the location of a data object.
struct DataLocation {
    // The index of the memory pool where this location is found.
    // Two special values can also be used.  See the LOCATION_* constants above.
    uint32_t poolIndex;
    // Offset in bytes from the start of the pool.
    uint32_t offset;
    // The length of the data, in bytes.
    uint32_t length;
};

struct Operand {
    OperandType type;
    vec<uint32_t> dimensions;

    // The number of operations that uses this operand as input.
    // TODO It would be nice to track the actual consumers, e.g. vec<uint32_t> consumers;
    uint32_t numberOfConsumers;

    float scale;
    int32_t zeroPoint;

    // How the operand is used.
    OperandLifeTime lifetime;

    // Where to find the data for this operand.
    // If the lifetime is TEMPORARY_VARIABLE, MODEL_INPUT, or MODEL_OUTPUT:
    // - All the fields will be 0.
    // If the lifetime is CONSTANT_COPY:
    // - location.poolIndex is 0.
    // - location.offset is the offset in bytes into Model.operandValues.
    // - location.length is set.
    // If the lifetime is CONSTANT_REFERENCE:
    // - location.poolIndex is set.
    // - location.offset is the offset in bytes into the specified pool.
    // - location.length is set.
    DataLocation location;
};

// Describes one operation of the graph.
struct Operation {
    // The tuple describing the operation type and input type.
    OperationTuple opTuple;
    // Describes the table that contains the indexes of the inputs of the
    // operation. The offset is the index in the operandIndexes table.
    vec<uint32_t> inputs;
    // Describes the table that contains the indexes of the outputs of the
    // operation. The offset is the index in the operandIndexes table.
    vec<uint32_t> outputs;
};

struct Model {
    vec<Operand> operands;
    vec<Operation> operations;
    vec<uint32_t> inputIndexes;
    vec<uint32_t> outputIndexes;
    vec<uint8_t> operandValues;
    vec<memory> pools;
};

struct RequestArgument {
    // The location within one of the memory pools
    DataLocation location;
    // If dimensions.size() > 0, dimension information was provided along with the
    // argument.  This can be the case for models that accept inputs of varying size.
    // This can't change the rank, just the value of the dimensions that were
    // unspecified in the model.
    vec<uint32_t> dimensions;
};

struct Request {
    vec<RequestArgument> inputs;
    vec<RequestArgument> outputs;
    vec<memory> pools;
};

enum ErrorStatus : uint32_t {
    NONE,
    DEVICE_UNAVAILABLE,
    GENERAL_FAILURE,
    OUTPUT_INSUFFICIENT_SIZE,
    INVALID_ARGUMENT,
};
