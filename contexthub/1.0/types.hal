/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.contexthub@1.0;

enum Result : uint32_t {
    OK,                  // Success
    UNKNOWN_FAILURE,     // Failure, unknown reason
    BAD_PARAMS,          // Parameters not sane
    NOT_INIT,            // Not initialized
    TRANSACTION_FAILED,  // Transaction failed
    TRANSACTION_PENDING, // Pending transaction, cannot accept a new request
};

enum NanoAppFlags : uint32_t {
    SIGNED = (1<<0),   // Signed nanoapp
    ENCRYPTED = (1<<1),// Encrypted nanoapp
};

struct NanoAppBinary {
    uint32_t headerVersion;    // 0x1 for this version
    uint32_t magic;            // "NANO"
    uint64_t appId;            // App ID (contains vendor ID in most significant
                               // 5 bytes)
    uint32_t appVersion;       // Version of the app
    uint32_t flags;            // Mask of NanoAppFlags
    uint64_t hwHubType;        // Which hub type is this app is compiled for. A
                               // unique ID for each h/w + toolchain
                               // combination.
    vec<uint8_t> customBinary; // start of custom binary data
};

enum SensorType : uint32_t {
    RESERVED,
    ACCELEROMETER,
    GYROSCOPE,
    MAGNETOMETER,
    BAROMETER,
    PROXIMITY_SENSOR,
    AMBIENT_LIGHT_SENSOR,
    STATIONARY_DETECT,
    INSTANT_MOTION_DETECT,

    GPS = 0x100,
    // Reserving this space for variants on GPS

    WIFI = 0x200,
    // Reserving this space for variants on WIFI

    AUDIO = 0x300,
    // Reserving this space for variants on Audio

    CAMERA = 0x400,
    // Reserving this space for variants on Camera

    BLE = 0x500,
    // Reserving this space for variants on Bluetooth Low Energy

    WWAN = 0x600,
    // Reserving this space for variants on WWAN

    PRIVATE_SENSOR_BASE = 0x10000,
    // Sensor types beyond PRIVATE_SENSOR_BASE are custom types
};

struct PhysicalSensor{
    SensorType sensorType;       // From the definitions above eg: 100
    string type;                 // Type as a string. eg: "GPS"
    string name;                 // Identifier eg: "Bosch BMI160"
    string vendor;               // Vendor : eg "STM"
    uint32_t version;            // Version : eg 0x1001
    uint32_t fifoReservedCount;  // Batching possible in hardware. Please
                                 // note that here hardware does not include
                                 // the context hub itself. Thus, this
                                 // definition may be different from say the
                                 // number advertised in the sensors HAL
                                 // which allows for batching in a hub.
    uint32_t fifoMaxCount;       // Maximum number of batchable events.
    uint64_t minDelayMs;         // In milliseconds, corresponding to highest
                                 // sampling freq.
    uint64_t maxDelayMs;         // In milliseconds, corresponds to minimum
                                 // sampling frequency
    float peakPowerMw;           // At max frequency & no batching, power
                                 // in milliwatts
};

struct ContextHub {
    string name;                // Descriptive name eg: "Awesome Hub #1"
    string vendor;              // Hub hardware vendor eg: "Qualcomm"
    string toolchain;           // Toolchain to make binaries eg: "gcc ARM"
    uint32_t platformVersion;   // Version of the hardware : eg 0x20
    uint32_t toolchainVersion;  // Version of the toolchain : eg: 0x484
    uint32_t hubId;             // A device unique ID for this hub

    float peakMips;             // Peak MIPS platform can deliver
    float stoppedPowerDrawMw;   // If stopped, retention power, milliwatts
    float sleepPowerDrawMw;     // If sleeping, retention power, milliwatts
    float peakPowerDrawMw;      // For a busy CPU, power in milliwatts

    vec<PhysicalSensor> connectedSensors; // Array of connected sensors

    uint32_t maxSupportedMsgLen;// This is the maximum size of the message that can
                                // be sent to the hub in one chunk (in bytes)
};

struct ContextHubMsg {
    uint64_t appName; // Intended recipient (appId)
    uint32_t msgType; // Identifier for message
    vec<uint8_t> msg; // Message body
};

enum HubMemoryType : uint32_t {
    MAIN      = 0, // Main memory
    SECONDARY = 1, // Secondary memory
    TCM       = 2, // Tightly coupled memory
};

enum HubMemoryFlag : uint32_t {
    READ  = (1<<0), // Readable
    WRITE = (1<<1), // Writable
    EXEC  = (1<<2), // Executable
};

struct MemRange {
    uint32_t totalBytes; // Total capacity in bytes
    uint32_t freeBytes;  // Free capacity in bytes
    HubMemoryType type;  // Type of memory, see HubMemoryType
    uint32_t flags;      // Mask of HubMemoryFlag
};

enum AsyncEventType : uint32_t {
    RESTARTED = 1,   // Hub restarted unexpectedly
};

enum TransactionResult : int32_t {
    SUCCESS,      // Successful completion of transaction
    FAILURE,      // Failed transaction
};

struct HubAppInfo {
    uint64_t appId;         // Identifier of the app
    uint32_t version;       // Version of the app
    vec<MemRange> memUsage; // Memory used by this app
    bool enabled;           // true if the app is currently enabled and running,
                            // or false if in the loaded but disabled state
};

