/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.nfc@1.0;

import INfcClientCallback;

interface INfc {
    /*
     * Opens the NFC controller device and performs initialization.
     * This may include patch download and other vendor-specific initialization.
     *
     * If open completes successfully, the controller should be ready to perform
     * NCI initialization - ie accept CORE_RESET and subsequent commands through
     * the write() call.
     *
     * If open() returns 0, the NCI stack will wait for a NfcEvent.OPEN_CPLT
     * before continuing.
     *
     * If open() returns any other value, the NCI stack will stop.
     *
     */
    open(INfcClientCallback clientCallback) generates (int32_t retval);

    /*
     * Performs an NCI write.
     *
     * This method may queue writes and return immediately. The only
     * requirement is that the writes are executed in order.
     */
    write(NfcData data) generates (int32_t retval);

    /*
     * coreInitialized() is called after the CORE_INIT_RSP is received from the NFCC.
     * At this time, the HAL can do any chip-specific configuration.
     *
     * If coreInitialized() returns 0, the NCI stack will wait for a NfcEvent.POST_INIT_CPLT
     * before continuing.
     *
     * If coreInitialized() returns any other value, the NCI stack will continue
     * immediately.
     */
    coreInitialized(NfcData data) generates (int32_t retval);

    /*
     * prediscover is called every time before starting RF discovery.
     * It is a good place to do vendor-specific configuration that must be
     * performed every time RF discovery is about to be started.
     *
     * If prediscover() returns 0, the NCI stack will wait for a NfcEvent.PREDISCOVER_CPLT
     * before continuing.
     *
     * If prediscover() returns any other value, the NCI stack will start
     * RF discovery immediately.
     */
    prediscover() generates (int32_t retval);

    /*
     * Close the NFC controller. Should free all resources.
     */
    close() generates (int32_t retval);

    /*
     * Grant HAL the exclusive control to send NCI commands.
     * Called in response to NfcEvent.REQUEST_CONTROL.
     * Must only be called when there are no NCI commands pending.
     * NfcEvent.RELEASE_CONTROL will notify when HAL no longer needs exclusive control.
     */
    controlGranted() generates (int32_t retval);

     /*
     * Restart controller by power cyle;
     * NfcEvent.OPEN_CPLT will notify when operation is complete.
     */
    powerCycle() generates (int32_t retval);
};
